
#include <asm/ECPT.h>
#include <asm/ECPT_defs.h>

#include <linux/panic.h>

#ifdef CONFIG_DEBUG_BEFORE_CONSOLE
#include <asm/early_debug.h>
#else

#undef DEBUG_STR
#define DEBUG_STR(__x)
#undef DEBUG_VAR
#define DEBUG_VAR(__x)

#endif


uint32_t way_to_crN[ECPT_MAX_WAY]= {ECPT_WAY_TO_CR_SEQ};

/* crc32.c
   Copyright (C) 2009-2021 Free Software Foundation, Inc.

   This file is part of the libiberty library.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   In addition to the permissions in the GNU General Public License, the
   Free Software Foundation gives you unlimited permission to link the
   compiled version of this file into combinations with other programs,
   and to distribute those combinations without any restriction coming
   from the use of this file.  (The General Public License restrictions
   do apply in other respects; for example, they cover modification of
   the file, and distribution when not linked into a combined
   executable.)

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
*/




/* This table was generated by the following program.

   #include <stdio.h>

   int
   main ()
   {
     unsigned int i, j;
     unsigned int c;
     int table[256];

     for (i = 0; i < 256; i++)
       {
	 for (c = i << 24, j = 8; j > 0; --j)
	   c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
	 table[i] = c;
       }

     printf ("static const unsigned int crc32_table[] =\n{\n");
     for (i = 0; i < 256; i += 4)
       {
	 printf ("  0x%08x, 0x%08x, 0x%08x, 0x%08x",
		 table[i + 0], table[i + 1], table[i + 2], table[i + 3]);
	 if (i + 4 < 256)
	   putchar (',');
	 putchar ('\n');
       }
     printf ("};\n");
     return 0;
   }

   For more information on CRC, see, e.g.,
   http://www.ross.net/crc/download/crc_v3.txt.  */

// static const unsigned int crc32_table[] =
// {
//   0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
//   0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
//   0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
//   0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
//   0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
//   0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
//   0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
//   0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
//   0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
//   0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
//   0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
//   0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
//   0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
//   0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
//   0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
//   0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
//   0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
//   0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
//   0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
//   0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
//   0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
//   0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
//   0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
//   0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
//   0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
//   0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
//   0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
//   0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
//   0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
//   0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
//   0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
//   0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
//   0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
//   0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
//   0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
//   0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
//   0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
//   0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
//   0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
//   0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
//   0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
//   0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
//   0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
//   0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
//   0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
//   0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
//   0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
//   0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
//   0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
//   0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
//   0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
//   0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
//   0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
//   0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
//   0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
//   0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
//   0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
//   0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
//   0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
//   0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
//   0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
//   0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
//   0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
//   0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
// };

/*

@deftypefn Extension {unsigned int} crc32 (const unsigned char *@var{buf}, @
  int @var{len}, unsigned int @var{init})

Compute the 32-bit CRC of @var{buf} which has length @var{len}.  The
starting value is @var{init}; this may be used to compute the CRC of
data split across multiple buffers by passing the return value of each
call as the @var{init} parameter of the next.

This is used by the @command{gdb} remote protocol for the @samp{qCRC}
command.  In order to get the same results as gdb for a block of data,
you must pass the first CRC parameter as @code{0xffffffff}.

This CRC can be specified as:

  Width  : 32
  Poly   : 0x04c11db7
  Init   : parameter, typically 0xffffffff
  RefIn  : false
  RefOut : false
  XorOut : 0

This differs from the "standard" CRC-32 algorithm in that the values
are not reflected, and there is no final XOR value.  These differences
make it easy to compose the values of multiple blocks.

@end deftypefn

*/

// unsigned int
// xcrc32 (const unsigned char *buf, int len, unsigned int init)
// {
//   unsigned int crc = init;
//   while (len--)
//     {
//       crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
//       buf++;
//     }
//   return crc;
// }



// static uint32_t crc32_hash(uint32_t vpn) {
// 	// return crc32_be(0, (const unsigned char * ) &addr, 4); /* hash uint32 so length is 4 bytes */
// 	return xcrc32((const unsigned char * ) &vpn, 4, 0xffffffff);
    
// }

// static uint64_t gen_hash_32(uint32_t vpn, uint64_t size) {
//     uint64_t hash = crc32_hash(vpn);
//     hash = hash % size;
//     if (hash > size) {
//         /* should not be */
//         // printf("Hash value %lu, size %lu\n", hash, size);
//         // assert(1 == 0 && "Hash value is larger than index\n");
// 		panic("Hash value is larger than index\n");
//     }

//     return hash;
// }

// unsigned int
// early_xcrc32 (const unsigned char *buf, int len, unsigned int init,  uint64_t kernel_start, uint64_t physaddr)
// {
//   unsigned int crc = init;
//   const unsigned int * fixup_crc32_table = (const unsigned int *) ((void *) crc32_table - (void *)kernel_start + (void *)physaddr);
  
//   while (len--)
//     {
//       crc = (crc << 8) ^ fixup_crc32_table[((crc >> 24) ^ *buf) & 255];
//       buf++;
//     }
//   return crc;
// }

// static uint64_t early_gen_hash_32(uint32_t vpn, uint64_t size, uint64_t kernel_start, uint64_t physaddr) {
//     uint64_t hash = early_xcrc32((const unsigned char * ) &vpn, 4, 0xffffffff, kernel_start, physaddr);
	
// 	hash = hash % size;

//     return hash;
// }

static uint64_t crc64_table[256] = {
0x0000000000000000UL,
0x42f0e1eba9ea3693UL,
0x85e1c3d753d46d26UL,
0xc711223cfa3e5bb5UL,
0x493366450e42ecdfUL,
0x0bc387aea7a8da4cUL,
0xccd2a5925d9681f9UL,
0x8e224479f47cb76aUL,
0x9266cc8a1c85d9beUL,
0xd0962d61b56fef2dUL,
0x17870f5d4f51b498UL,
0x5577eeb6e6bb820bUL,
0xdb55aacf12c73561UL,
0x99a54b24bb2d03f2UL,
0x5eb4691841135847UL,
0x1c4488f3e8f96ed4UL,
0x663d78ff90e185efUL,
0x24cd9914390bb37cUL,
0xe3dcbb28c335e8c9UL,
0xa12c5ac36adfde5aUL,
0x2f0e1eba9ea36930UL,
0x6dfeff5137495fa3UL,
0xaaefdd6dcd770416UL,
0xe81f3c86649d3285UL,
0xf45bb4758c645c51UL,
0xb6ab559e258e6ac2UL,
0x71ba77a2dfb03177UL,
0x334a9649765a07e4UL,
0xbd68d2308226b08eUL,
0xff9833db2bcc861dUL,
0x388911e7d1f2dda8UL,
0x7a79f00c7818eb3bUL,
0xcc7af1ff21c30bdeUL,
0x8e8a101488293d4dUL,
0x499b3228721766f8UL,
0x0b6bd3c3dbfd506bUL,
0x854997ba2f81e701UL,
0xc7b97651866bd192UL,
0x00a8546d7c558a27UL,
0x4258b586d5bfbcb4UL,
0x5e1c3d753d46d260UL,
0x1cecdc9e94ace4f3UL,
0xdbfdfea26e92bf46UL,
0x990d1f49c77889d5UL,
0x172f5b3033043ebfUL,
0x55dfbadb9aee082cUL,
0x92ce98e760d05399UL,
0xd03e790cc93a650aUL,
0xaa478900b1228e31UL,
0xe8b768eb18c8b8a2UL,
0x2fa64ad7e2f6e317UL,
0x6d56ab3c4b1cd584UL,
0xe374ef45bf6062eeUL,
0xa1840eae168a547dUL,
0x66952c92ecb40fc8UL,
0x2465cd79455e395bUL,
0x3821458aada7578fUL,
0x7ad1a461044d611cUL,
0xbdc0865dfe733aa9UL,
0xff3067b657990c3aUL,
0x711223cfa3e5bb50UL,
0x33e2c2240a0f8dc3UL,
0xf4f3e018f031d676UL,
0xb60301f359dbe0e5UL,
0xda050215ea6c212fUL,
0x98f5e3fe438617bcUL,
0x5fe4c1c2b9b84c09UL,
0x1d14202910527a9aUL,
0x93366450e42ecdf0UL,
0xd1c685bb4dc4fb63UL,
0x16d7a787b7faa0d6UL,
0x5427466c1e109645UL,
0x4863ce9ff6e9f891UL,
0x0a932f745f03ce02UL,
0xcd820d48a53d95b7UL,
0x8f72eca30cd7a324UL,
0x0150a8daf8ab144eUL,
0x43a04931514122ddUL,
0x84b16b0dab7f7968UL,
0xc6418ae602954ffbUL,
0xbc387aea7a8da4c0UL,
0xfec89b01d3679253UL,
0x39d9b93d2959c9e6UL,
0x7b2958d680b3ff75UL,
0xf50b1caf74cf481fUL,
0xb7fbfd44dd257e8cUL,
0x70eadf78271b2539UL,
0x321a3e938ef113aaUL,
0x2e5eb66066087d7eUL,
0x6cae578bcfe24bedUL,
0xabbf75b735dc1058UL,
0xe94f945c9c3626cbUL,
0x676dd025684a91a1UL,
0x259d31cec1a0a732UL,
0xe28c13f23b9efc87UL,
0xa07cf2199274ca14UL,
0x167ff3eacbaf2af1UL,
0x548f120162451c62UL,
0x939e303d987b47d7UL,
0xd16ed1d631917144UL,
0x5f4c95afc5edc62eUL,
0x1dbc74446c07f0bdUL,
0xdaad56789639ab08UL,
0x985db7933fd39d9bUL,
0x84193f60d72af34fUL,
0xc6e9de8b7ec0c5dcUL,
0x01f8fcb784fe9e69UL,
0x43081d5c2d14a8faUL,
0xcd2a5925d9681f90UL,
0x8fdab8ce70822903UL,
0x48cb9af28abc72b6UL,
0x0a3b7b1923564425UL,
0x70428b155b4eaf1eUL,
0x32b26afef2a4998dUL,
0xf5a348c2089ac238UL,
0xb753a929a170f4abUL,
0x3971ed50550c43c1UL,
0x7b810cbbfce67552UL,
0xbc902e8706d82ee7UL,
0xfe60cf6caf321874UL,
0xe224479f47cb76a0UL,
0xa0d4a674ee214033UL,
0x67c58448141f1b86UL,
0x253565a3bdf52d15UL,
0xab1721da49899a7fUL,
0xe9e7c031e063acecUL,
0x2ef6e20d1a5df759UL,
0x6c0603e6b3b7c1caUL,
0xf6fae5c07d3274cdUL,
0xb40a042bd4d8425eUL,
0x731b26172ee619ebUL,
0x31ebc7fc870c2f78UL,
0xbfc9838573709812UL,
0xfd39626eda9aae81UL,
0x3a28405220a4f534UL,
0x78d8a1b9894ec3a7UL,
0x649c294a61b7ad73UL,
0x266cc8a1c85d9be0UL,
0xe17dea9d3263c055UL,
0xa38d0b769b89f6c6UL,
0x2daf4f0f6ff541acUL,
0x6f5faee4c61f773fUL,
0xa84e8cd83c212c8aUL,
0xeabe6d3395cb1a19UL,
0x90c79d3fedd3f122UL,
0xd2377cd44439c7b1UL,
0x15265ee8be079c04UL,
0x57d6bf0317edaa97UL,
0xd9f4fb7ae3911dfdUL,
0x9b041a914a7b2b6eUL,
0x5c1538adb04570dbUL,
0x1ee5d94619af4648UL,
0x02a151b5f156289cUL,
0x4051b05e58bc1e0fUL,
0x87409262a28245baUL,
0xc5b073890b687329UL,
0x4b9237f0ff14c443UL,
0x0962d61b56fef2d0UL,
0xce73f427acc0a965UL,
0x8c8315cc052a9ff6UL,
0x3a80143f5cf17f13UL,
0x7870f5d4f51b4980UL,
0xbf61d7e80f251235UL,
0xfd913603a6cf24a6UL,
0x73b3727a52b393ccUL,
0x31439391fb59a55fUL,
0xf652b1ad0167feeaUL,
0xb4a25046a88dc879UL,
0xa8e6d8b54074a6adUL,
0xea16395ee99e903eUL,
0x2d071b6213a0cb8bUL,
0x6ff7fa89ba4afd18UL,
0xe1d5bef04e364a72UL,
0xa3255f1be7dc7ce1UL,
0x64347d271de22754UL,
0x26c49cccb40811c7UL,
0x5cbd6cc0cc10fafcUL,
0x1e4d8d2b65facc6fUL,
0xd95caf179fc497daUL,
0x9bac4efc362ea149UL,
0x158e0a85c2521623UL,
0x577eeb6e6bb820b0UL,
0x906fc95291867b05UL,
0xd29f28b9386c4d96UL,
0xcedba04ad0952342UL,
0x8c2b41a1797f15d1UL,
0x4b3a639d83414e64UL,
0x09ca82762aab78f7UL,
0x87e8c60fded7cf9dUL,
0xc51827e4773df90eUL,
0x020905d88d03a2bbUL,
0x40f9e43324e99428UL,
0x2cffe7d5975e55e2UL,
0x6e0f063e3eb46371UL,
0xa91e2402c48a38c4UL,
0xebeec5e96d600e57UL,
0x65cc8190991cb93dUL,
0x273c607b30f68faeUL,
0xe02d4247cac8d41bUL,
0xa2dda3ac6322e288UL,
0xbe992b5f8bdb8c5cUL,
0xfc69cab42231bacfUL,
0x3b78e888d80fe17aUL,
0x7988096371e5d7e9UL,
0xf7aa4d1a85996083UL,
0xb55aacf12c735610UL,
0x724b8ecdd64d0da5UL,
0x30bb6f267fa73b36UL,
0x4ac29f2a07bfd00dUL,
0x08327ec1ae55e69eUL,
0xcf235cfd546bbd2bUL,
0x8dd3bd16fd818bb8UL,
0x03f1f96f09fd3cd2UL,
0x41011884a0170a41UL,
0x86103ab85a2951f4UL,
0xc4e0db53f3c36767UL,
0xd8a453a01b3a09b3UL,
0x9a54b24bb2d03f20UL,
0x5d45907748ee6495UL,
0x1fb5719ce1045206UL,
0x919735e51578e56cUL,
0xd367d40ebc92d3ffUL,
0x1476f63246ac884aUL,
0x568617d9ef46bed9UL,
0xe085162ab69d5e3cUL,
0xa275f7c11f7768afUL,
0x6564d5fde549331aUL,
0x279434164ca30589UL,
0xa9b6706fb8dfb2e3UL,
0xeb46918411358470UL,
0x2c57b3b8eb0bdfc5UL,
0x6ea7525342e1e956UL,
0x72e3daa0aa188782UL,
0x30133b4b03f2b111UL,
0xf7021977f9cceaa4UL,
0xb5f2f89c5026dc37UL,
0x3bd0bce5a45a6b5dUL,
0x79205d0e0db05dceUL,
0xbe317f32f78e067bUL,
0xfcc19ed95e6430e8UL,
0x86b86ed5267cdbd3UL,
0xc4488f3e8f96ed40UL,
0x0359ad0275a8b6f5UL,
0x41a94ce9dc428066UL,
0xcf8b0890283e370cUL,
0x8d7be97b81d4019fUL,
0x4a6acb477bea5a2aUL,
0x089a2aacd2006cb9UL,
0x14dea25f3af9026dUL,
0x562e43b4931334feUL,
0x913f6188692d6f4bUL,
0xd3cf8063c0c759d8UL,
0x5dedc41a34bbeeb2UL,
0x1f1d25f19d51d821UL,
0xd80c07cd676f8394UL,
0x9afce626ce85b507UL
};


#define puthex_tabtabln(num) { \
		debug_putstr(tab); \
		debug_putstr(tab); \
		debug_puthex(num); \
		debug_putstr(line_break); \
	}

uint64_t crc64_be(uint64_t crc, const void* p, uint64_t len, uint64_t * table) {
  uint64_t i, t;

  const unsigned char* _p = (const unsigned char*) (p);

  for (i = 0; i < len; i++) {
    t = ((crc >> 56) ^ (*_p++)) & 0xFF;
    crc = table[t] ^ (crc << 8);
  }
  return (crc);
}


static uint64_t gen_hash_64(uint64_t vpn, uint64_t size) {
    uint64_t hash = crc64_be(0xffffffff,
					&vpn,
					5, /* at most we need five of them */ 
					crc64_table
	);
    hash = hash % size;

    return hash;
}

static uint64_t early_gen_hash_64(uint64_t vpn, uint64_t size, uint64_t kernel_start, uint64_t physaddr) {
	uint64_t hash;
	uint64_t * fixup_crc64_table = (uint64_t *) ((void *) crc64_table - (void *)kernel_start + (void *)physaddr);

	hash = crc64_be(0xffffffff,
					&vpn,
					5, /* at most we need five of them */ 
					fixup_crc64_table
	);

	hash = hash % size;
    return hash;
}

#define puthexln(num) { \
		debug_puthex(num); \
		debug_putstr(line_break); \
	}

#define puthex_tabln(num) { \
		debug_putstr(tab); \
		debug_puthex(num); \
		debug_putstr(line_break); \
	}

/**
 * @brief Get a way different from @cur_way
 * 
 * @param cur_way 	current way number
 * @param n_way 	number of ways in this ECPT
 * @return uint32_t 
 */
static uint32_t get_diff_rand(uint32_t cur_way, uint32_t n_way) {
	
	uint32_t way = cur_way;


	if (n_way == 1) return way;

	// DEBUG_VAR(rng_is_initialized());
	
	do
	{
		if (rng_is_initialized()) {
			pr_info_verbose("call get random\n");
			way = get_random_u32();
		} else {
			way += 1;
		}

		way = way % n_way;
	} while (way == cur_way);
	
	return way;
}

/**
 * @brief 
 * 
 * @param ecpt  pointer has not been fixed up, but cr values should be fixed up
 * @param vaddr 
 * @param paddr 
 * @param prot 
 * @param kernel_start 
 * @param physaddr 
 * @return int 
 */

static void * fixup_pointer(void *ptr, uint64_t kernel_start, uint64_t physaddr)
{
	return (void * )((uint64_t) ptr - kernel_start + physaddr);
} 



int early_ecpt_insert(
	ECPT_desc_t * ecpt,
	uint64_t vaddr, 
	uint64_t paddr, 
	ecpt_pgprot_t prot, 
	uint64_t kernel_start, 
	uint64_t physaddr
) {

	uint64_t size;
	uint64_t hash;
	uint64_t vpn;
	uint64_t cr;

	ECPT_desc_t * ecpt_fixed;
	ecpt_entry_t * ecpt_base;
	ecpt_entry_t * entry_ptr;

	ecpt_entry_t entry, temp;
	static uint16_t way = 0;
	uint16_t tries = 0;

	char tab[2] = "\t";
	char line_break[2] = "\n";

	if (!ECPT_2M_WAY) return -1;
	ecpt_fixed = (ECPT_desc_t *) fixup_pointer(ecpt, kernel_start, physaddr);

	/* this function always run with two 2MB */
	way += 1;
	way = way % ECPT_2M_WAY;
	// get_random_bytes(&way, 2);
	// way = way % ECPT_2M_WAY;
	

	vpn = ADDR_TO_PAGE_NUM_2MB(vaddr);

	entry.pte = ADDR_REMOVE_OFFSET_2MB(paddr) | ecpt_pgprot_val(prot);
	entry.VPN_tag = vpn;

	if (!(entry.pte & _PAGE_PRESENT)) {
		return 0;
	}

	puthexln(vaddr);

	for (tries = 0; tries < ECPT_INSERT_MAX_TRIES; tries++) {
		puthex_tabln(way);
		cr = ecpt_fixed->table[ECPT_4K_WAY + way];

		/* fixup cr here, because it is the virtual address to ecpt table */
		cr = (uint64_t) fixup_pointer((void *) cr, kernel_start, physaddr);
		
		size = GET_HPT_SIZE(cr);
		puthex_tabln(vpn);
		hash = early_gen_hash_64(vpn, size, kernel_start, physaddr);
		puthex_tabln(hash);
		ecpt_base = (ecpt_entry_t *) GET_HPT_BASE_VIRT(cr);
		entry_ptr = &ecpt_base[hash];
		
		if (!ecpt_entry_present(entry_ptr)) {
			/* can insert here */
						
			set_ecpt_entry(entry_ptr, entry);
			puthex_tabln((uint64_t) entry_ptr);
			puthex_tabln(entry_ptr->pte);

			ecpt_fixed->occupied[ECPT_4K_WAY + way] += 1;
			return 0;
		} else {
			/* swap and insert again */

			temp = *entry_ptr;
			set_ecpt_entry(entry_ptr, entry);
			entry = temp;
		}	
		
		way += 1;
		way = way % ECPT_2M_WAY;
	// 	do
	// 	{
	// 		way += 1;
	// way = way % ECPT_2M_WAY;
	// 	} while (way == new_way);
		
		// way = new_way;

	}

	debug_putstr(line_break);

	return -1;

}

int early_ecpt_invalidate(ECPT_desc_t * ecpt, uint64_t vaddr) {
	uint32_t way_start = ECPT_4K_WAY;
	uint32_t way_end = ECPT_4K_WAY + ECPT_2M_WAY;
	uint32_t w;

	uint64_t cr, size, hash;
	uint64_t vpn = ADDR_TO_PAGE_NUM_2MB(vaddr);

	ecpt_entry_t *entry_ptr, *ecpt_base;
	DEBUG_VAR(vaddr);
	if (!ECPT_2M_WAY) return -2;

	for (w = way_start; w < way_end; w++) {


		cr = ecpt->table[w];
		size = GET_HPT_SIZE(cr);

		if (size == 0) {
			/* early tables shoundn't hit here */
			BUG();
		}

		hash = gen_hash_64(vpn, size);
		
		/* stay with current hash table */
		ecpt_base = (ecpt_entry_t * ) GET_HPT_BASE_VIRT(cr);
		entry_ptr = &ecpt_base[hash];

		if (entry_ptr->VPN_tag == vpn) {
			DEBUG_VAR((uint64_t)entry_ptr);
			break;
		} else {
			/* not found move on */
			entry_ptr = NULL;
		}
	}

	if (!entry_ptr) {
		return -1;
	}
	/* clear entry  */
	memset(entry_ptr, 0, sizeof(*entry_ptr));
	ecpt->occupied[w] -= 1;
	return 0;
}

/*
static Granularity way_to_granularity(uint32_t way) {
	if (way < ECPT_4K_WAY) {
		return page_4KB;
	} else if (way < ECPT_4K_WAY + ECPT_2M_WAY) {
		return page_2MB;
	} else if (way < ECPT_4K_WAY + ECPT_2M_WAY + ECPT_1G_WAY) {
		return page_1GB;
	} else {
		return unknown;
	}
}
*/

static uint64_t way_to_vpn(uint32_t way, uint64_t vaddr) {
	if (way < ECPT_4K_WAY) {
		return ADDR_TO_PAGE_NUM_4KB(vaddr); 
	} 
	else if (way < ECPT_4K_WAY + ECPT_2M_WAY) {
		return ADDR_TO_PAGE_NUM_2MB(vaddr); 
	} 
	else if (way < ECPT_4K_WAY + ECPT_2M_WAY + ECPT_1G_WAY) {
		return ADDR_TO_PAGE_NUM_1GB(vaddr); 
	} 
	else if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY) {
		return ADDR_TO_PAGE_NUM_4KB(vaddr); 
	} 
	else if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY) {
		return ADDR_TO_PAGE_NUM_2MB(vaddr); 
	} 
	else if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY + ECPT_1G_USER_WAY) {
		return ADDR_TO_PAGE_NUM_1GB(vaddr); 
	}
	else {
		BUG();
		return 0;
	}
}

static uint64_t way_to_gran(uint32_t way) {
	if (way < ECPT_4K_WAY) {
		return page_4KB; 
	} 
	else if (way < ECPT_4K_WAY + ECPT_2M_WAY) {
		return page_2MB; 
	} 
	else if (way < ECPT_4K_WAY + ECPT_2M_WAY + ECPT_1G_WAY) {
		return page_1GB; 
	} 
	else if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY) {
		return page_4KB; 
	} 
	else if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY) {
		return page_2MB;
	} 
	else if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY + ECPT_1G_USER_WAY) {
		return page_1GB;
	}
	else {
		BUG();
		return 0;
	}
}

/* LOG helper function, support integer up to 32 bits */
#define LOG_1(n) (((n) >= 2) ? 1 : 0)
#define LOG_2(n) (((n) >= 1<<2) ? (2 + LOG_1((n)>>2)) : LOG_1(n))
#define LOG_4(n) (((n) >= 1<<4) ? (4 + LOG_2((n)>>4)) : LOG_2(n))
#define LOG_8(n) (((n) >= 1<<8) ? (8 + LOG_4((n)>>8)) : LOG_4(n))
#define LOG(n)   (((n) >= 1<<16) ? (16 + LOG_8((n)>>16)) : LOG_8(n))

static uint64_t alloc_way_default(uint32_t n_entries) {
	uint64_t addr, cr;
	uint64_t nr_pages = EPCT_NUM_ENTRY_TO_NR_PAGES (n_entries);
	uint32_t order = LOG(nr_pages);
	
	// pr_info_verbose("order=%x\n", order);
	addr = __get_free_pages(GFP_PGTABLE_USER, order);

	if (!addr) {
		return 0;
	}
	
	WARN(addr & HPT_SIZE_MASK, "addr=%llx not 4K aligned\n", addr);

	cr = addr + HPT_NUM_ENTRIES_TO_CR3(n_entries);
	return cr;
}

static inline uint64_t alloc_4K_way_default(void) {
	uint64_t cr = alloc_way_default(ECPT_4K_PER_WAY_ENTRIES);
	WARN(!cr, "cannot allocate %x entries total size=%lx\n",
		ECPT_4K_PER_WAY_ENTRIES, ECPT_4K_PER_WAY_ENTRIES * sizeof(ecpt_entry_t));
	return cr;
}

static inline uint64_t alloc_2M_way_default(void) {
	uint64_t cr = alloc_way_default(ECPT_2M_PER_WAY_ENTRIES);
	WARN(!cr, "cannot allocate %x entries total size=%lx\n",
		ECPT_2M_PER_WAY_ENTRIES, ECPT_2M_PER_WAY_ENTRIES * sizeof(ecpt_entry_t));
	return cr;
}

static inline uint64_t alloc_1G_way_default(void) {
	uint64_t cr = alloc_way_default(ECPT_1G_PER_WAY_ENTRIES);
	WARN(!cr, "cannot allocate %x entries total size=%lx\n",
		ECPT_1G_PER_WAY_ENTRIES, ECPT_1G_PER_WAY_ENTRIES * sizeof(ecpt_entry_t));
	return cr;
}

/**
 * @brief 
 * 	only allocate user ways. kernel ways are copied from init_mm.map_desc
 * 		or the PTI kernel ways
 * @return void* The ECPT desc
 */
static ECPT_desc_t * map_desc_alloc_default(void) {
	ECPT_desc_t * desc;
	uint16_t way = ECPT_KERNEL_WAY;
	desc = kzalloc(sizeof(ECPT_desc_t), GFP_PGTABLE_USER);
	
	WARN(!desc, "cannot allocate ecpt_desc=%lx\n", sizeof(ECPT_desc_t));
	if (desc == NULL)
		goto out;

	// dump_stack();
	// mm->map_desc = desc;

	for (; way < ECPT_TOTAL_WAY; way++) {
		if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY) {

			if (ECPT_4K_WAY_EAGER) {
				desc->table[way] = alloc_4K_way_default();
			} else {
				desc->table[way] = 0;
			}

		} else if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY) {
			
			if (ECPT_2M_WAY_EAGER) {
				desc->table[way] = alloc_2M_way_default();
			} else {
				desc->table[way] = 0;
			}
				
		} else if (way < ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY + ECPT_1G_USER_WAY) {
			
			if (ECPT_2M_WAY_EAGER) {
				desc->table[way] = alloc_1G_way_default();
			} else {
				desc->table[way] = 0;
			}
		
		} else {
			/* should not enter here */
			BUG();
		}
	}

	return desc;
out:
	return NULL;
}


/**
 * @brief copy all kernel entries 
 * 		Right now, copy all since we don't have user entries yet
 * 
 * @param dest 
 * @param src 
 */
static void ecpt_kernel_copy(ECPT_desc_t * dest, ECPT_desc_t * src) {
	// uint16_t w = 0;
	WARN(src != &ecpt_desc, 
			"copy from %llx (not kernel ecpt_desc) to %llx",
			(uint64_t) src, (uint64_t) dest);

	/* ad hoc cuz we only have kernel mapping entries for now */
	memcpy(dest->table, src->table, sizeof(dest->table[0]) * ECPT_KERNEL_WAY);
	memcpy(dest->occupied, src->occupied, sizeof(dest->occupied[0]) * ECPT_KERNEL_WAY);
}

static inline void ecpt_set_mm(ECPT_desc_t * ecpt, struct mm_struct *mm) {
	ecpt->mm = mm; 
}

static inline void ecpt_list_add(ECPT_desc_t * ecpt) {
	list_add(&ecpt->lru, &pgd_list);
}

static inline void ecpt_list_del(ECPT_desc_t * ecpt) {
	list_del(&ecpt->lru);
}

static void ecpt_ctor(struct mm_struct *mm, ECPT_desc_t * new_desc) {

	ecpt_kernel_copy(new_desc, (ECPT_desc_t *) init_mm.map_desc);
	
	/* list required to sync kernel mapping updates */
	if (!SHARED_KERNEL_PMD) {
		ecpt_set_mm(new_desc, mm);
		ecpt_list_add(new_desc);
	}
}

static void ecpt_dtor(ECPT_desc_t * ecpt)
{
	if (SHARED_KERNEL_PMD)
		return;

	spin_lock(&pgd_lock);
	ecpt_list_del(ecpt);
	spin_unlock(&pgd_lock);
}

/**
 * TODO: fix name
 * 
 * @param mm 
 * @return void* 
 */
void * pgd_alloc(struct mm_struct *mm) {
	void* desc = map_desc_alloc_default();
	
	WARN(!desc, "map_desc_alloc_default fails\n");
	
	mm->map_desc = desc;

	/**
	 * no need to preallocate any PMD or copy kernel PGD entries here
	 * 	we don't need such preallocation 
	 */
	
	spin_lock(&pgd_lock);
	ecpt_ctor(mm, desc);
	spin_unlock(&pgd_lock);

	return desc;
}	


/**
 * @brief based on vaddr and granularity
 * 	select all possible ways that can contain such entries
 */

static void select_way(
	uint64_t vaddr, Granularity gran, /* input */
	uint32_t * way_start, uint32_t * way_end, uint64_t * vpn /* output */
) {
	uint16_t is_kernel_vaddr = IS_KERNEL_MAP(vaddr);

	if (gran == page_4KB) {	
		if (is_kernel_vaddr) {
			*way_start = 0;
			*way_end = ECPT_4K_WAY;
		} else {
			*way_start = ECPT_KERNEL_WAY;
			*way_end = ECPT_KERNEL_WAY + ECPT_4K_USER_WAY;
		}
		
		*vpn = ADDR_TO_PAGE_NUM_4KB(vaddr); 
	} 
	else if (gran == page_2MB) {
		if (is_kernel_vaddr) {
			*way_start = ECPT_4K_WAY;
			*way_end = ECPT_4K_WAY + ECPT_2M_WAY;
		} else {
			*way_start = ECPT_KERNEL_WAY + ECPT_4K_USER_WAY;
			*way_end = ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY;
		}

		*vpn = ADDR_TO_PAGE_NUM_2MB(vaddr); 
	} 
	else if (gran == page_1GB) {
		if (is_kernel_vaddr) {
			*way_start = ECPT_4K_WAY + ECPT_2M_WAY;
			*way_end = ECPT_4K_WAY + ECPT_2M_WAY + ECPT_1G_WAY;
		} else {
			*way_start = ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY;
			*way_end = ECPT_KERNEL_WAY + ECPT_4K_USER_WAY + ECPT_2M_USER_WAY + ECPT_1G_USER_WAY;
		}

		*vpn = ADDR_TO_PAGE_NUM_1GB(vaddr); 
	} 
	else if (gran == unknown) {
		/* unknown granularity */
		if (is_kernel_vaddr) {
			*way_start = 0;
			*way_end = ECPT_KERNEL_WAY;
		} else {
			*way_start = ECPT_KERNEL_WAY;
			*way_end = ECPT_KERNEL_WAY + ECPT_USER_WAY;
		}

		*vpn = 0;
	} else {
		BUG();
	}

}

static void fix_lazy_ECPT(ECPT_desc_t * ecpt , Granularity gran) {
	uint64_t (*way_allocator) (void);
	uint32_t way_start, way_end, way;
	uint64_t tmp;

	if (gran == page_4KB) {
		way_allocator = &alloc_4K_way_default;
	} else if (gran == page_2MB) {
		way_allocator = &alloc_2M_way_default;
	} else if (gran == page_1GB) {
		way_allocator = &alloc_1G_way_default;
	} else {
		way_allocator = NULL;
		WARN(1, "gran=%d\n", gran);
		return;
	}

	select_way(
		0x1000, /* we only fix up user page table */
		gran,
		&way_start,
		&way_end,
		&tmp /* place holder */
	);

	pr_info_verbose("fixup for way_start=%x way_end=%x\n", way_start, way_end);
	for (way = way_start; way < way_end; way++) {
		ecpt->table[way] = way_allocator();
	}
	
}	

ecpt_entry_t * get_hpt_entry(ECPT_desc_t * ecpt, uint64_t vaddr, Granularity * g, uint32_t * way) {

	uint64_t size, hash, vpn, cr, rehash_ptr = 0;

	uint32_t w = 0, way_start, way_end;

	ecpt_entry_t * ecpt_base;
	ecpt_entry_t * entry_ptr = NULL;
	ecpt_entry_t entry;
	Granularity gran = *g;
	/* this m */
	
	select_way(
		vaddr, gran,		/* input */
		&way_start, &way_end, &vpn	/* output */
	);


	for (w = way_start; w < way_end; w++) {
		if (gran == unknown) {
			vpn = way_to_vpn(w, vaddr);
		}

		cr = ecpt->table[w];
		size = GET_HPT_SIZE(cr);

		if (size == 0) {
			/* way that has not been built becuase of lazy alloc of ECPT */
			continue;
		}

		hash = gen_hash_64(vpn, size);
		
		// DEBUG_VAR(hash);
		// DEBUG_VAR(w);

		if (hash < rehash_ptr) {
            /* not supported for resizing now */
            /* rehash_ptr MBZ right now */
            panic("no rehash support!\n");
        } else {
			/* stay with current hash table */
            ecpt_base = (ecpt_entry_t * ) GET_HPT_BASE_VIRT(cr);
            entry_ptr = &ecpt_base[hash];

		}
        entry = *entry_ptr;

		// DEBUG_VAR(entry.VPN_tag);
		if (entry.VPN_tag == vpn) {
			
			// DEBUG_VAR((uint64_t) entry_ptr);
			if (gran == unknown) *g = way_to_gran(w);
			*way = w;
			return entry_ptr;
		} else {
			/* not found move on */
			entry_ptr = NULL;
		}
	}
	*g = unknown;
	*way = -1;
	return entry_ptr;
}

int ecpt_insert(ECPT_desc_t * ecpt, uint64_t vaddr, uint64_t paddr, ecpt_pgprot_t prot, Granularity gran) {
	
	uint64_t size, hash, vpn, cr, rehash_ptr = 0;

	uint32_t way_start = 0, way_end, n_way;
	static uint32_t way = 0;

	ecpt_entry_t * ecpt_base;
	ecpt_entry_t * entry_ptr;
	ecpt_entry_t entry, temp;

	uint16_t tries = 0;

	// pr_info_verbose("ecpt at %llx vaddr=%llx paddr=%llx prot=%lx gran=%d\n", (uint64_t) ecpt ,vaddr, paddr, prot.pgprot, gran);


	if (gran == unknown) {
		WARN(1, KERN_WARNING "gran=%d\n", gran);
		return -1;
	}

	select_way(
		vaddr, gran,		/* input */
		&way_start, &way_end, &vpn	/* output */
	);
	n_way = way_end - way_start;
	
	/* calculate PPN */
	if (gran == page_4KB) 
	{
		entry.pte = ADDR_REMOVE_OFFSET_4KB(paddr);
	} 
	else if (gran == page_2MB) 
	{
		entry.pte = ADDR_REMOVE_OFFSET_2MB(paddr);
	} 
	else if (gran == page_1GB) 
	{
		entry.pte = ADDR_REMOVE_OFFSET_1GB(paddr);
	} 
	else 
	{
		/* invalid granularity */
		return -1;
	}

	if (n_way == 0) {

		/* invalid size */
		return -2;
	}

	entry.pte = entry.pte | ecpt_pgprot_val(prot);
	if (gran == page_2MB || gran == page_1GB) {
		entry.pte = entry.pte | _PAGE_PSE;
	}

	entry.VPN_tag = vpn;

	way = get_diff_rand(way, n_way);
	// DEBUG_VAR(vaddr);

	for (tries = 0; tries < ECPT_INSERT_MAX_TRIES; tries++) {
		// puthex_tabln(way);
		
		cr = ecpt->table[way_start + way];
		// DEBUG_VAR(cr);
		size = GET_HPT_SIZE(cr);
		if (size == 0) {
			fix_lazy_ECPT(ecpt, gran);
			
			cr = ecpt->table[way_start + way];
			size = GET_HPT_SIZE(cr);
			
			if (!size) {
				// pr_info_verbose("gran=%d way = %d\n", gran, way_start + way);
				BUG_ON(!size);
			}
		}

		hash = gen_hash_64(vpn, size);
		// puthex_tabln(hash);


		if (hash < rehash_ptr) {
            /* not supported for resizing now */
            /* rehash_ptr MBZ right now */
            panic("no rehash support!\n");
        } else {
			/* stay with current hash table */
            ecpt_base = (ecpt_entry_t * ) GET_HPT_BASE_VIRT(cr);
			// DEBUG_VAR((uint64_t)ecpt_base);
            entry_ptr = &ecpt_base[hash];

		}
            
		
		if (!ecpt_entry_present(entry_ptr)) {
			/* can insert here */
			// pr_info_verbose("hash=%llx way=%d entry_ptr=%llx pte=%llx\n", 
					// hash, way_start + way, (uint64_t) entry_ptr, entry.pte);
			set_ecpt_entry(entry_ptr, entry);
			ecpt->occupied[way_start + way] += 1;
			return 0;
		} else {
			/* swap and insert again */
			
			temp = *entry_ptr;
			if (temp.VPN_tag == entry.VPN_tag && temp.pte == entry.pte) {
				/* mapping already established, no need to kick it out */
				return 0;
			}
			pr_info_verbose("kick temp={.vpn=%llx .pte=%llx} with entry={.vpn=%llx .pte=%llx}\n", temp.VPN_tag, temp.pte, entry.VPN_tag, entry.pte);
			set_ecpt_entry(entry_ptr, entry);
			entry = temp;
				
		}	
		
		way = get_diff_rand(way, n_way);

	}
	// pr_info_verbose("collision cannot be resolved.\n");
	// pr_info_verbose("collision cannot be resolved: ecpt at %llx vaddr=%llx paddr=%llx prot=%lx gran=%d\n", 
	// 		(uint64_t) ecpt ,vaddr, paddr, prot.pgprot, gran);
	print_ecpt(ecpt);
	WARN(1, KERN_WARNING"Hash Collision unresolved:\n ecpt at %llx vaddr=%llx paddr=%llx prot=%lx gran=%d\n", 
			(uint64_t) ecpt ,vaddr, paddr, prot.pgprot, gran);
	/* exceed max number of tries */
	return -3;
}

int ecpt_mm_insert(struct mm_struct* mm, uint64_t vaddr, uint64_t paddr, ecpt_pgprot_t prot, Granularity gran) {
	int res = 0;

	spin_lock(&mm->page_table_lock);

	res = ecpt_insert(
		(ECPT_desc_t *) mm->map_desc,
		vaddr,
		paddr,
		prot,
		gran
	);
	spin_unlock(&mm->page_table_lock);
	return res;
}

/**
 * @brief code borrowed from https://github.com/sgh185/nautilus/blob/carat-cake-artifact/src/aspace/paging/paging.c
 * 
 * @param mm 
 * @param vaddr 
 * @param vaddr_end 
 * @param paddr 
 * @param paddr_end 
 * @param prot 
 * @return int 
 */

int ecpt_mm_insert_range(
	struct mm_struct* mm, 
	uint64_t vaddr, 
	uint64_t vaddr_end,
	uint64_t paddr, 
	uint64_t paddr_end,
	ecpt_pgprot_t prot
) {
	int res = 0;

	Granularity gran = unknown;
	uint64_t remained = vaddr_end - vaddr;
	uint64_t page_granularity = 0;

	/**
	 * when condiction == T,
	 * 	cond should be the be bad case
	 */
	BUG_ON((vaddr_end - vaddr != paddr_end - paddr));

	while (vaddr < vaddr_end) {
        if (
            ECPT_1G_WAY && 
            vaddr % PAGE_SIZE_1GB == 0 && 
            paddr % PAGE_SIZE_1GB == 0 && 
            remained >= PAGE_SIZE_1GB
        ) {
            gran = page_1GB;
			page_granularity = PAGE_SIZE_1GB;
        } 
        else if (
            ECPT_2M_WAY && 
            vaddr % PAGE_SIZE_2MB == 0 && 
            paddr % PAGE_SIZE_2MB == 0 && 
            remained >= PAGE_SIZE_2MB 
        ) {
            gran = page_2MB;
			page_granularity = PAGE_SIZE_2MB;
        } 
        else if (
            vaddr % PAGE_SIZE_4KB == 0 && 
            paddr % PAGE_SIZE_4KB == 0 && 
            remained >= PAGE_SIZE_4KB 
        ) {
            // vaddr % PAGE_SIZE_4KB == 0
            // must be the case as we require 4KB alignment
            gran = page_4KB;
			page_granularity = PAGE_SIZE_4KB;
        } else {
            pr_err(" doesnot meet drill requirement at vaddr=0x%llx and paddr=0x%llx\n", vaddr, paddr);
            return -1;
        }

		spin_lock(&mm->page_table_lock);

        res = ecpt_insert(
			(ECPT_desc_t *) mm->map_desc,
			vaddr,
			paddr,
			prot,
			gran
		);

		spin_unlock(&mm->page_table_lock);

        if (res < 0) {
            pr_err("Failed to drill at virtual address=%llx"
                    " physical adress %llx"
                    " and ret code of %d"
                    " page_granularity = %llx\n",
                    vaddr, paddr, res, page_granularity
            );
            return res;
        }

        vaddr += page_granularity;
        paddr += page_granularity;
        remained -= page_granularity;
    }

	return res;
}

int ecpt_invalidate(ECPT_desc_t * ecpt_desc, uint64_t vaddr, Granularity g) {
	

	
	ecpt_entry_t * entry = NULL;
	uint32_t way;
	// DEBUG_VAR(vaddr);
	entry = get_hpt_entry(ecpt_desc, vaddr, &g, &way);
	
	if (entry == NULL) {
		/* no such entry */
		return -1;
	}
	
	entry->pte = 0;

	/**
	 * TODO: if PTE clustering is supported we don't clear VPN_tag
	 */
	entry->VPN_tag = 0;
	ecpt_desc->occupied[way] -= 1;

	// DEBUG_STR("\n");

	return 0;
}

int ecpt_mm_invalidate(struct mm_struct* mm, uint64_t vaddr, Granularity gran) {
	int res = 0;
	spin_lock(&mm->page_table_lock);

	res = ecpt_invalidate(
		(ECPT_desc_t *) mm->map_desc,
		vaddr,
		gran
	);
	spin_unlock(&mm->page_table_lock);
	
	return res;
}

ecpt_entry_t ecpt_peek(ECPT_desc_t * ecpt, uint64_t vaddr, Granularity * gran) {
	ecpt_entry_t empty = {.VPN_tag = 0, .pte = 0};
	uint32_t way_temp;
	ecpt_entry_t * entry_p = get_hpt_entry(ecpt, vaddr, gran, &way_temp);

	if (entry_p == NULL) {
		pr_warn("WARN: vaddr=%llx gran=%d doesn't exist", vaddr, *gran);
		*gran = unknown;
		return empty;
	}

	return *entry_p;
}

ecpt_entry_t ecpt_mm_peek(struct mm_struct* mm, uint64_t vaddr, Granularity * gran) {

	ecpt_entry_t entry;
	spin_lock(&mm->page_table_lock);

	entry = ecpt_peek(
		(ECPT_desc_t *) mm->map_desc,
		vaddr,
		gran
	);

	spin_unlock(&mm->page_table_lock);

	return entry;
}

int ecpt_update_prot(ECPT_desc_t * ecpt, uint64_t vaddr, ecpt_pgprot_t new_prot, Granularity gran) {

	uint64_t pte_val;
	ecpt_entry_t * entry_p;
	uint32_t way_temp;
	entry_p = get_hpt_entry(ecpt, vaddr, &gran, &way_temp);

	if (entry_p == NULL) {
		WARN(1, KERN_WARNING "entry_p == NULL\n");
		return -1;
	}

	if (!ecpt_entry_present(entry_p)) {
		pr_warn("Cannot update protection for entry that is not present\n");
		return -1;
	}

	pte_val = ENTRY_TO_ADDR(entry_p->pte) | new_prot.pgprot;

	entry_p->pte = pte_val;

	return 0;
}

int ecpt_mm_update_prot(struct mm_struct* mm, uint64_t vaddr, ecpt_pgprot_t new_prot, Granularity gran) {

	int res;
	spin_lock(&mm->page_table_lock);

	// cr3 = (uint64_t) mm->pgd;
	// /* hpt_base is pointer to ecpt_pmd_t, pointer arithmetic, by default, conside the size of the object*/
	res = ecpt_update_prot((ECPT_desc_t *) mm->map_desc, vaddr, new_prot, gran);

	spin_unlock(&mm->page_table_lock);
	// /* hpt_base is pointer to ecpt_pmd_t, pointer arithmetic, by default, conside the size of the object*/
	// return res;
	return 0;
}


/* Why memory clobber here */

/**
 * @brief  ## concatenates symbol together e.g. native_write_cr##N -> native_write_cr1
 * 			# turns input into string tokens e.g. "mov %0,%%cr"#N -> "mov %0,%%cr" "1" -> "mov %0,%%cr1"
 * 
 */
#define DEFINE_native_write_crN(N) \
static inline void native_write_cr##N(unsigned long val) {\
	asm volatile("mov %0,%%cr"#N: : "r" (val) : "memory"); \
}

DEFINE_native_write_crN(1)
DEFINE_native_write_crN(5)
DEFINE_native_write_crN(6)
DEFINE_native_write_crN(7)
DEFINE_native_write_crN(9)
DEFINE_native_write_crN(10)
DEFINE_native_write_crN(11)
DEFINE_native_write_crN(12)

#define DEFINE_load_crN(N) \
	static inline void load_cr##N(uint64_t cr) \
{ \
	native_write_cr##N(__sme_pa(cr)); \
}


DEFINE_load_crN(1)
DEFINE_load_crN(5)
DEFINE_load_crN(6)
DEFINE_load_crN(7)
DEFINE_load_crN(9)
DEFINE_load_crN(10)
DEFINE_load_crN(11)
DEFINE_load_crN(12)

static inline void load_cr3_ECPT(uint64_t cr)
{
	write_cr3(__sme_pa(cr) | CR3_TRANSITION_BIT);
}

typedef void(*load_cr_func)(uint64_t);

static load_cr_func load_funcs[9] = {
	&load_cr3_ECPT,
	&load_cr1,
	&load_cr5,
	&load_cr6,
	&load_cr7,
	&load_cr9,
	&load_cr10,
	&load_cr11,
	&load_cr12
};

/**
 * @brief load ECPT desc tables -> corresponding control registers
 * 
 * @param ecpt 
 */
void load_ECPT_desc(ECPT_desc_t * ecpt) {
	uint16_t i;
	load_cr_func f;
	BUG_ON(ECPT_TOTAL_WAY > ECPT_MAX_WAY);


	/* load ecpt table -> control registers */
	for (i = 1; i < ECPT_TOTAL_WAY; i++) {
		f = load_funcs[i];
		(*f)(ecpt->table[i]);
	}

	/* load cr3 in the end because it it will flush TLB */
	f = load_funcs[0];
	(*f)(ecpt->table[0]);
} 

void print_ecpt(ECPT_desc_t * ecpt) {
	uint16_t i ;

	if (ecpt == &ecpt_desc) 
		pr_info("show root ECPT ------------------\n");
	else
		pr_info("show ECPT at %llx ------------------\n", (uint64_t) ecpt);
	
	pr_info("Kernel tables: \n");
	for (i = 0; i < ECPT_KERNEL_WAY; i++) {
		pr_info("\t 0x%x/0x%llx %llx -> cr%d \n",
			ecpt->occupied[i], GET_HPT_SIZE(ecpt->table[i]), 
			ecpt->table[i], way_to_crN[i] );
	}

	pr_info("User tables: \n");
	for (i = ECPT_KERNEL_WAY; i < ECPT_TOTAL_WAY; i++) {
		pr_info("\t 0x%x/0x%llx %llx -> cr%d \n",
			ecpt->occupied[i], GET_HPT_SIZE(ecpt->table[i]), 
			ecpt->table[i], way_to_crN[i]);
	}
	
	if (ecpt->mm == &init_mm)
		pr_info("\tmm = init_mm");
	else 
		pr_info("\tmm at %llx \n", (uint64_t) ecpt->mm);
	
	pr_info("\t ecpt->lru.next=%llx\n", (uint64_t)ecpt->lru.next);
	pr_info("\t ecpt->lru.prev=%llx\n", (uint64_t)ecpt->lru.prev);
	
	pr_info("End of ECPT at %llx ------------------", (uint64_t) ecpt);

}